# dentaku

## syntax

```
statement       = define-variable
                | define-unary
                | define-binary
                | expression
define-variable = ID '=' expression
define-unary    = UOP ID '=' expression
define-binary   = ID BOP ID '=' expression
expression      = conditional { ',' conditional }
conditional     = binary { '?' binary ':' conditional }
binary          = or { BOP or }
or              = and { 'or' and }
and             = comp { 'and' comp }
comp            = add { ('==' | '!=' | '<' | '<=' | '>' | '>=' | '~' | '!~') add}
add             = mult { ('+' | '-') mult }
mult            = power { ('*' | '/' | '%') power }
power           = unary [ '^' power ]
unary           = primary | [ '@' ] UOP unary
primary         = '(' [ expression ] ')'
                | VAR
                | NUMBER
```

## token

```
ID        = ID-FIRST { ID-REST }
ID-FIRST  = JAVA-ALPHABETIC | '_'
ID-FIRST  = ID-FIRST | JAVA-DIGIT | '.'
BOP       = ID | SPECIAL
UOP       = ID | SPECIAL
VAR       = ID
NUMBER    = DIGITS
            [ '.' DIGITS ]
            [ ( 'e' | 'E' ) [ '+' | '-' ] DIGITS ]
DIGITS    = DIGIT { DIGIT }
DIGIT     = '0' .. '9'
```

## UOP

単項演算子

## BOP

二項演算子

## 選択演算子

`prime`は素数判定を行い結果を`1`(真)または`0`(偽)として返します。
1から10までの数列に対して適用すると以下のようになります。

```
    prime iota 10
0, 1, 1, 0, 1, 0, 1, 0, 0, 0
```

先頭に選択演算子`@`を付与すると真となった要素(素数)だけを抽出します。

```
    @ prime iota 10
2, 3, 5, 7
```

## 評価例

### `+`と`-`

単項の`+`は`+`による簡約です。
```
    + (1, 2, 3)
6
```

単項の`-`は以下のように動作します。
```
    - (1, 2)
-1
```
```
    - (1, 2, 3)
-4
```
```
    -1
-1
```

### 負の数値

```
    1, -2, 3
1, -2, 3
```

単項の`*`は`*`による簡約です。
```
    * (1, 2, 3, 4)
24
```
```
    a = 1, 2, 3, 4
    * a
24
```

### 並びを使った計算

$$\sqrt{{11^4+100^4+111^4}\over 2}
$$

```
    sqrt ((11 ^ 4 + 100 ^ 4 + 111 ^ 4) / 2)
11221
    sqrt + ((11, 100, 111) ^ 4 / 2)
11221
```
### 偏差値の計算

＜国語のテスト＞
|A|B|C|D|E|
|-:|-:|-:|-:|-:|
|55|60|70|60|65|

＜数学のテスト＞
|A|B|C|D|E|
|-:|-:|-:|-:|-:|
|25|95|40|90|60|

```
    平均 x = + x / count x
    分散 x = + ((x - 平均 x) ^ 2) / count x
    標準偏差 x = sqrt 分散 x
    偏差値 x = (x - 平均 x) / 標準偏差 x * 10 + 50
    国語 = 55, 60, 70, 60, 65
    算数 = 25, 95, 40, 90, 60
    平均 国語
62
    平均 算数
62
    分散 国語
26
    分散 算数
746
    標準偏差 国語
5.0990195135927848300282241090227819895637709460995964075849708044259336320622241955883488510939320083611902582410399106614317793411215362998027726261199368133520082339240815865151806094369250287447031
    標準偏差 算数
27.313000567495325997676106081194337386568183428498142064475174787273532495706576602831365672048570385138257860186312811595296552444249220669159851160112487450207135549667445865298123857835125118888259
    偏差値 国語 round 2
36.27, 46.08, 65.69, 46.08, 55.88
    偏差値 算数 round 2
36.45, 62.08, 41.95, 60.25, 49.27
```

### 2点間の距離

平面上の2点$(a_x,a_y)$と$(b_x,b_y)$の距離は次式で計算できます。

$$\sqrt{(a_x-b_x)^2+(a_y-b_y)^2}$$

$(0,0)$と$(1,1)$の距離は以下のように計算できます。

```
    a 距離 b = sqrt + square (a - b)
    (0, 0) 距離 (1, 1)
1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727350138462309122970249248360558507372126441214970999358314132226659275055927557999505011527820605715
```
この`距離`の定義は3次元以上の距離も同様に計算できます。

```
    (0, 0, 0) 距離 (1, 1, 1)
1.732050807568877293527446341505872366942805253810380628055806979451933016908800037081146186757248575675626141415406703029969945094998952478811655512094373648528093231902305582067974820101084674923265
```

### フィボナッチ数列の一般項

WikiPediaによるとフィボナッチ数列の一般項は以下のようになります。
これは以下のように計算できます。

$$
F_{n}
={\frac {1}{\sqrt {5}}}\left\{\left({\frac {1+{\sqrt {5}}}{2}}\right)^{n}-\left({\frac {1-{\sqrt {5}}}{2}}\right)^{n}\right\}
$$


```
    フィボナッチ n = (((1 + sqrt 5) / 2) ^ n - ((1 - sqrt 5) / 2) ^ n) / sqrt 5
    int フィボナッチ iota0 10
0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

引数に自然数を与えても結果は必ずしも自然数にならないので`int`で結果を丸めています。
`round`を使って丸めることもできます。
`round`の後の`0`は丸めた後の小数点以下の桁数です。

```
    フィボナッチ iota0 10 round 0
0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```

### πの計算

$tan^{-1}$を求めるライプニッツ (Leibniz)の式は以下のとおりです。

$$arctan\:1 = {\pi \over 4} = \sum_{n=0}^\infty {(-1)^{n} \over {2n+1}}$$

合計する項の数を増やすしながら計算すると以下のようになります。

```
    term n = -1 ^ n / (2 * n + 1)
    pi n = + term iota0 n * 4
    pi 10
3.041839618929402211135957265988225740547721971870578681724192560105872799371251383635284564077133736576461034665369030694108093488898442458813975841839618929402211135957265988225740547721971870578681740
    pi 100
3.1315929035585527643074142382769205164030543844065756513896620765015246091009528643658229824888576983495220510617996475163427117133423169446225367592296232418247610424442544150230128626296824166262729720
    pi 1000
3.14059265383979292596359650286939597045138933077972448936745778354190793123974760826517233200767020723140388527603871089993806662955221456455123774288715005044051233930253707282585276024662802556200859016
    pi 10000
3.141492653590043238459518383374815378787013642744180460513479805474395670690028850870632943186765515712449180270879595216656138346723053240857425165370145476523667024194024852565525340949987938859407311604
    pi 100000
3.1415826535897934884626433520295028937284193939649495759086359919592690551729875945272168247348045291378616410833374403367230534872598909920887472292990473998461346290444135431394162868269590211668899099600
```
おおよそ項の数が一桁増えると精度が一桁上がることがわかります。

### シグマ

$$
\sum_{n=1}^{40000}{ 1\over{\sqrt n}}
$$

各要素の逆数を求める単項演算子`/`を使って以下のように求めることができます。

```
    + / sqrt iota 40000
2.1865080895951406181348043000693115201541410478320914270294071387943193960693323084664827336722501629782127015498988579343319322855795599971961020093053482460730936212458643341141549647502716310115892E-83357
```

### ソルバー

問題：$a b c d e f = a+b+c+d+e+f$を満たす自然数の組は何通りか。

`.solve 式`は`式`を満たす変数の値の組を見つけて表示します。

```
    a = 1 to 10
    b = 1 to 10
    c = 1 to 10
    d = 1 to 10
    e = 1 to 10
    f = 1 to 10
    .solve a * b * c * d * e * f == a + b + c + d + e + f
a=1 b=1 c=1 d=1 e=2 f=6
a=1 b=1 c=1 d=1 e=6 f=2
a=1 b=1 c=1 d=2 e=1 f=6
a=1 b=1 c=1 d=2 e=6 f=1
a=1 b=1 c=1 d=6 e=1 f=2
a=1 b=1 c=1 d=6 e=2 f=1
a=1 b=1 c=2 d=1 e=1 f=6
a=1 b=1 c=2 d=1 e=6 f=1
a=1 b=1 c=2 d=6 e=1 f=1
a=1 b=1 c=6 d=1 e=1 f=2
a=1 b=1 c=6 d=1 e=2 f=1
a=1 b=1 c=6 d=2 e=1 f=1
a=1 b=2 c=1 d=1 e=1 f=6
a=1 b=2 c=1 d=1 e=6 f=1
a=1 b=2 c=1 d=6 e=1 f=1
a=1 b=2 c=6 d=1 e=1 f=1
a=1 b=6 c=1 d=1 e=1 f=2
a=1 b=6 c=1 d=1 e=2 f=1
a=1 b=6 c=1 d=2 e=1 f=1
a=1 b=6 c=2 d=1 e=1 f=1
a=2 b=1 c=1 d=1 e=1 f=6
a=2 b=1 c=1 d=1 e=6 f=1
a=2 b=1 c=1 d=6 e=1 f=1
a=2 b=1 c=6 d=1 e=1 f=1
a=2 b=6 c=1 d=1 e=1 f=1
a=6 b=1 c=1 d=1 e=1 f=2
a=6 b=1 c=1 d=1 e=2 f=1
a=6 b=1 c=1 d=2 e=1 f=1
a=6 b=1 c=2 d=1 e=1 f=1
a=6 b=2 c=1 d=1 e=1 f=1
number of solutions=30
```

## 優先順位

|優先順位|演算子|結合|-|
|-|-|-|-|
|1|+, -, UOP|右結合|単項演算子|
|2|^|右結合|べき乗|
|3|*, /, %|左結合|乗除算|
|4|+, -|左結合|加減算|
|5|==, !=, <, <=, >, >=, ~, !~|左結合|比較|
|6|and|左結合|論理積|
|7|or, xor|左結合|(排他的)論理和|
|8|BOP|左結合|その他の二項演算子|
|9|,|左結合|連結|

# 遅延評価

`G`オペレータが`F`オペレータを参照している場合、
パース時に`F`オペレータの定義を取得するとすれば、
後から`F`オペレータの定義を変更しても
`G`オペレータの定義が変更されることはありません。
しかし`G`オペレータは実行時に`"F"`の名前で`F`
オペレータを参照するので問題はありません。

```
    F x = x + 1
    G x = F x + 1
    G 0
2
    F x = x + 2
    G 0
3
```

# 機能拡張

## ソルバー

### 実行例1

変数`a`を1から5、変数`b`を0から10まで
変えながら式$a ^ 2 + b ^ 2 = 25$を評価し、
真(ゼロ以外)の場合に変数`a`および`b`の値を出力します。

```
    a = 1 to 5
    b = 0 to 10
    .solve a ^ 2 + b ^ 2 == 25
a=3 b=4
a=4 b=3
a=5 b=0
number of solutions=3
```

あるいは

```
    a = 1 to 5
    b = 0 to 10
    .solve + ((a, b) ^ 2) == 25
a=3 b=4
a=4 b=3
a=5 b=0
number of solutions=3
```

### 実行例2

$$
{3 \over a} + {5 \over b} + {7 \over c}
$$
が整数となる素数$a, b, c$をすべて求めよ。

```
    isint n = int n == n
    a = @ prime iota 40
    b = @ prime iota 40
    c = @ prime iota 40
    .solve isint + ((3, 5, 7) / (a, b, c))
a=2 b=2 c=7
a=2 b=5 c=2
a=3 b=2 c=2
a=3 b=3 c=3
a=3 b=5 c=7
a=5 b=5 c=5
number of solutions=6
```

### 実行例3

$2^{p-1}-1 = pq^2$を満たす$p, q$をすべて求めよ。
ただし$p,q$は異なる素数とする。

```
    p = @ prime iota 1000
    q = @ prime iota 1000
    .solve 2 ^ (p - 1) - 1 = q ^ 2 * p and p != q
Extra token '='
```
`and p != q`がなくても同じ結果になる。

### 実行例4

$${_{2n}C_n\over{n+1}}
$$
が素数のとき、
正の整数$n$をすべて求めよ。

```
    n = 1 to 100
    .solve prime ((2 * n C n) / (n + 1))
n=2
n=3
number of solutions=2
```

### 実行例5

$(x^3-x)^2(y^3-y)=86400$を満たす整数$x, y$の組をすべて求めよ。

```
    x = -100 to 100
    y = -100 to 100
    .solve (x ^ 3 - x) ^ 2 * (y ^ 3 - y) == 86400
x=-5 y=2
x=-4 y=3
x=4 y=3
x=5 y=2
number of solutions=4
```

あるいは

```
    x = -100 to 100
    y = -100 to 100
    C3 x = x ^ 3 - x
    .solve C3 x ^ 2 * C3 y == 86400
x=-5 y=2
x=-4 y=3
x=4 y=3
x=5 y=2
number of solutions=4
```

単項演算子`C3`の定義内で変数`x`を使用している点に注意する。
この変数は`.solve`における式内の`x`とは区別されている。

### 実行例6

以下を満たす素数$p,q,r$を求めよ。

$$
3p^4-5q^4-4r^2=26
$$
```
    p = @ prime iota 100
    q = @ prime iota 100
    r = @ prime iota 100
    .solve 3 * p ^ 4 - 5 * q ^ 4 - 4 * r ^ 2 == 26
p=5 q=3 r=19
number of solutions=1
```

### 実行例7

2桁の整数$m$を2乗すると下2桁が36になる。$m$をすべて求めよ。

```
    m = 10 to 99
    .solve m ^ 2 % 100 == 36
m=44
m=56
m=94
number of solutions=3
```

ソルバーを使わずに求めることもできます。

```
    sq36 m = m ^ 2 % 100 == 36
    @ sq36 (10 to 99)
44, 56, 94
```

あるいは

```
    m = 10 to 99
    m filter m ^ 2 % 100 == 36
44, 56, 94
```

### 実行例8

以下の式を満たす自然数$a, b, c$を求めよ。

$$
a ^ 2 + b ^ 2 + c ^ 2 = 292
$$

```
    a = iota 100
    b = iota 100
    c = iota 100
    .solve + square (a, b, c) == 292
a=2 b=12 c=12
a=12 b=2 c=12
a=12 b=12 c=2
number of solutions=3
```

### 実行例9

以下の式を満たす自然数$a, b, c$を求めよ。

$$
2 ^ a + 4 ^ b + 8 ^ c = 328
$$

```
    a = iota 100
    b = iota 100
    c = iota 100
    .solve 2 ^ a + 4 ^ b + 8 ^ c == 328
a=3 b=4 c=2
a=6 b=4 c=1
a=8 b=3 c=1
number of solutions=3
```

### 実行例10

$p$が素数のとき、以下の式を満たす$m, n$を求めよ。

$$
5 ^ n - 3 ^ n = p ^ m
$$
```
    p = @ prime iota 100
    n = iota 100
    m = iota 100
    .solve 5 ^ n - 3 ^ n == p ^ m
m=1 n=1 p=2
m=4 n=2 p=2
number of solutions=2
```

### 実行例11

自然数$n$の約数は4個でその和は84である。

```
    n = iota 100
    .solve count divisor n == 4 and + divisor n == 84
n=65
number of solutions=1
```
